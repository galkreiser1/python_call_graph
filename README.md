# Python Call Graph Extension

## Description

The Python Call Graph Extension for vsCode visualizes the call graph of your Python code, providing insights into function calls, class methods, and basic module imports. This extension helps you understand the structure and dependencies within your code by generating an interactive graph that you can explore and filter.

## Features

- **Graph Visualization**: View an interactive call graph of your Python code.
- **Node Filtering**: Filter nodes by name, in-degree, and out-degree.
- **Edge Filtering**: Filter edges by type (calls, contains, inherits, etc).
- **Search Functionality**: Search for specific nodes in the graph.
- **Context Menu**: Right-click on nodes to navigate to the code or set breakpoints.

## Supported Python Features

The call graph generated by this extension supports the following Python features:

- **Function Definitions**: Including regular functions and methods within classes.
- **Class Definitions**: Including inheritance relationships.
- **Module Imports**: Imported modules and functions. Does not differentiate between classes and methods. Does not access the module code.
- **Function Calls**: Direct function calls and method calls.
- **Lambda Functions**: Definitions and usage of lambda functions.
- **Variable Assignments**: Including potential calls through assigned variables.
- **List of Functions**: Handling lists of functions - assumes they are all being called (very basic)
- **Inheritance**: Tracking inheritance relationships between classes.
- **Built-In Functions**: Including built-in functions like print(), len(), etc.
- also very partial support to function decorators.

## Prerequisites

- 'networkx' and 'astor' python libraries are required - please run install_dependencies.py to install them or do so manually.

## Installation

1. download the vsix file and 'install_dependencies.py' (if needed) into your chosen directory (or download the entire 'pilot' folder which contains these files as well as python script examples from the pilot)
2. run on terminal in same directory: 'code --install-extension python-call-graph-1.0.0.vsix'.
3. success message should appear in terminal.

## Usage

1. Open the python file in visual code studio.
2. Enter ctrl+shift+p and search for 'Show Python Call Graph' option
3. A graph will be generated in a new tab.

## Troubleshooting

Graph might not be generated after first intalling the extension. Simply try generating again (ctrl+shift+p -> 'Show Python Call Graph')

## Benchmarks

--usage--

1. can be found under 'benchmarks' folder.
2. simply run 'run_benchmarks.py' and wait for output.
3. set 'print_test_stats' var to either TRUE/FALSE if you want to see per-test stats in output or not.
4. the script also generates the script 'generated_callgraph.json' which you can compare to the expected output called 'callgraph.json'

--info--

The benchmarks for each test under each category contain both sound and complete results.
A call graph is sound if it contains all the edges that exist in the expected call grpah of a code (no false negatives).
A call graph is complete if it doesn't contain any edges that don't exist in the expected call graph (no false positives).

Most of the benchmarks tests were taken from the article, but some of them were edited and simplified to fit this current graph as it still lacks features that are supported in the article.
Additionally, the article had more benchmarks that this tool doesnt support.
The ones that were simplified are: classes, functions, imports, lambdas.

Also, in benchmarks 'classes' and 'mro' the soundness results are more significant, as this graph also supports inhertiance and 'contain method' edge types which are not tested in the article benchmarks, resulting in this graph generating more edges than expected (and thus making it not complete).

--Results--

Overall the graph succeeds in most basic use-cases accross the different benchmark categories it's supposed to support
For example - basic function calls, function assignments, imported function calls, class instances, multiple class inhertiance, super() invocation, self calls, inherited methods resolution, calls to builin functions, basic exception raise, and basic lambdas.

In the assignment benchmark it succeeded partially, showing support for chained and tuple assignments.

In the list benchmark it also showed only partial success, as the graph will draw 'potential call' edges to all functions in a list which is assigned to a variable.

In the direct_calls benchmark, which was taken 'as-is' from the article, we can see some of the limitations of this tool
in more complex use-cases of function-calls.
